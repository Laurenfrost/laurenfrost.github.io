---
title: c++变量回顾(更新中)
date: 2020-07-12 19:50:30
tags: C++
category: 并行计算
---
声明：  
本文基于Kurt Guntheroth所著*Optimized C++: Proven Techniques for Heightened Performance*的中文译本《C++性能优化指南》，人民邮电出版社，2018，杨文轩译。  

自从接触高性能计算问题，便深感计算机系统之繁杂。从底层的cpu架构、向量指令集、cache实现，到操作系统的进程/线程切换、编译器对代码的处理等等都无时无刻影响着程序执行的效率。且不论硬件和系统之类乱七八糟的东西，就拿开发者写出来的程序来说，一切高级语言的程序实现在经过编译器的转化后，程序在计算机底层的动作往往与开发者的想法有所出入。按理说现代计算机系统的设计指导思想之一就是抽象+封装。这种思想使得开发者无需考虑底层的工作机制，专心于自己眼前的事物，从而大大提升了开发者的工作效率。但不得不说这种层层抽象、层层封装的俄罗斯套娃是以牺牲计算性能为代价的。由于上层开发者不明白（一般也不需要明白）底层的内部实现方法，所以底层开发者必须保证他写的代码的可靠性，不得不让编译器生成的机器指令多做一些“无用功”。好在得益于几十年来硬件技术的改善，开发者所能使用的算力远非同日可语。在一般情形下，与这些俄罗斯套娃带来的便利相比，造成的计算性能的浪费无伤大雅。然而一旦对计算资源有所约束，又或者需要面对巨量的性能开销，就不得不考虑对程序的优化了。  
既然如前文所述，计算性能的浪费来自于上层开发者无视底层实现的自说自话，那么想要优化程序，自然就得从了解底层实现开始。这本《C++性能优化指南》就介绍了很多C++的标准和一些可能的编译器实现思路，相当值得参考。这里结合本人的经验，记录本书第六章关于C++变量的相关说法，方便以后查阅。  

## C++变量回顾  
C++每个变量（普通数据类型、数组、结构体、实例）在内存中的存储布局都是固定的，它们的大小在编译之时就已经确定了。  
C++允许程序获得变量的大小和指向该变量的指针，但不允许指定变量的每一位的布局。  
C++标准允许改变`struct`成员变量内部的顺序和布局，也提供了多个变量可以共享同一内存块的`union`，但程序所看到的联合是依赖于实现的。  

### 变量的存储期（生存周期）  
每个变量都有它自己的存储期，也叫生存周期。只有在这段时间内，变量所占用的存储空间和里面存储的值才是有意义的。C++不能直接指定变量的生存周期，只能从变量声明中推断。  
C++ 11中的生存周期有这几种：静态、线程局部、自动，以及动态生存周期。  
1. 静态生存周期  
    编译器会为每一个静态变量分配一个固定位置和固定大小的内存空间，该空间在其生存周期内会被一直保留。  

    * 全局静态变量在进入`main()`之前构建，退出`main()`后销毁。  
    * 函数内静态变量则在“程序执行第一次进入函数前”被构建。  
    *也就是说函数内静态变量可能和全局变量同时被构建，也可能直到第一次调用前才构建，这取决于编译器的具体实现。*  

    为静态变量创建存储空间没有运行时开销。  
    命名空间作用域内定义的变量，还有被声明为`static`或者`extern`的变量具有静态生存周期。


2. 线程局部生存周期  

3. 自动生存周期  

4. 动态生存周期  

### 变量的所有权  

### 值对象与实体对象  

## C++动态变量API回顾  

### 使用智能指针实现动态变量所有权的自动化  

### 动态变量的运行时开销  
